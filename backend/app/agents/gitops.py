"""
GitOps Agent
Intelligent agent responsible for managing test file generation and Git operations.

This agent handles:
  1. Creating well-structured test files from generated Playwright code
  2. Organizing files in the correct directory structure
  3. Managing Git operations (clone, branch, commit, push)
  4. Creating Pull Requests (optional)

In the agentic pipeline: AutomationEngineer → CodeReviewer → GitOps
"""

import os
import re
import asyncio
import shutil
import subprocess
from pathlib import Path
from datetime import datetime, timezone
from typing import Dict, Any, List, Optional

from loguru import logger
from app.core.config import settings
import stat


class GitOpsAgent:
    """
    Agent responsible for writing generated test files to a Git repository.
    
    This agent operates autonomously as part of the agentic pipeline:
    - Receives reviewed Playwright code
    - Creates properly structured .spec.ts files
    - Commits and pushes to the target repository
    
    It supports two modes:
    - LOCAL: Write files to a local directory (no Git push)
    - GIT: Clone repo, write files, commit, and push
    """
    
    def __init__(self):
        self.name = "GitOpsAgent"
        # Use absolute path to avoid path confusion during Git operations
        self.workspace_base = Path(settings.git_tests_workspace).absolute()
        self.workspace_base.mkdir(parents=True, exist_ok=True)
    
    def _cleanup_dir(self, path: Path):
        """Robustly delete a directory, handling read-only files (common in .git)."""
        if not path.exists():
            return
            
        def on_error(func, path, exc_info):
            """Error handler for shutil.rmtree to handle read-only files."""
            try:
                os.chmod(path, stat.S_IWRITE)
                func(path)
            except Exception as e:
                logger.warning(f"[{self.name}] Failed to delete {path}: {e}")

        try:
            if path.is_dir():
                shutil.rmtree(str(path), onerror=on_error)
            else:
                os.remove(str(path))
        except Exception as e:
            logger.warning(f"[{self.name}] Cleanup failed for {path}: {e}")

    def _sanitize_filename(self, title: str) -> str:
        """Convert a scenario title to a valid filename."""
        name = title.lower()
        name = re.sub(r'[^a-z0-9\s-]', '', name)
        name = re.sub(r'[\s]+', '-', name.strip())
        name = re.sub(r'-+', '-', name)
        return name[:80]  # Limit length
    
    def _generate_test_file_content(
        self,
        scenario_title: str,
        scenario_id: str,
        story_key: str,
        playwright_code: str,
        review_score: Optional[int] = None,
    ) -> str:
        """
        Generate a complete, well-structured .spec.ts file content.
        
        Wraps the generated Playwright code with proper imports,
        metadata comments, and file structure.
        """
        timestamp = datetime.now(timezone.utc).isoformat()
        
        # Check if code already has imports
        has_imports = "import" in playwright_code and "playwright" in playwright_code.lower()
        
        header = f"""/**
 * =============================================================================
 * Auto-Generated Playwright Test
 * =============================================================================
 * 
 * Story:     {story_key}
 * Scenario:  {scenario_title}
 * ID:        {scenario_id}
 * Generated: {timestamp}
 * Generator: Jira QA AI Generator (Agentic Pipeline)
 * 
 * Pipeline:  Story → AC → Scenarios → AutomationEngineer → CodeReviewer → GitOps
 * Review:    {"Score " + str(review_score) + "/10" if review_score else "N/A"}
 * 
 * ⚠️  This file was automatically generated by the AI agentic pipeline.
 *     Manual modifications may be overwritten on regeneration.
 * =============================================================================
 */
"""
        
        if has_imports:
            return f"{header}\n{playwright_code}\n"
        else:
            imports = """import { test, expect } from '@playwright/test';
"""
            return f"{header}\n{imports}\n{playwright_code}\n"
    
    async def write_test_files(
        self,
        story_key: str,
        scenarios: List[Dict[str, Any]],
    ) -> Dict[str, Any]:
        """
        Write test files to the local workspace.
        
        Args:
            story_key: Jira story key (e.g., "PROJ-123")
            scenarios: List of scenario dicts with keys:
                - id, title, playwright_code, review_score
                
        Returns:
            Result dict with created file paths and status
        """
        logger.info(f"[{self.name}] Writing test files for {story_key}...")
        
        result = {
            "success": False,
            "story_key": story_key,
            "files_created": [],
            "directory": "",
            "errors": []
        }
        
        try:
            # Create story-specific directory
            story_dir = self.workspace_base / story_key.lower().replace("-", "_")
            story_dir.mkdir(parents=True, exist_ok=True)
            result["directory"] = str(story_dir)
            
            for scenario in scenarios:
                try:
                    scenario_id = scenario.get("id", "TS-000")
                    title = scenario.get("title", "untitled")
                    code = scenario.get("playwright_code", "")
                    review_score = scenario.get("review_score")
                    
                    if not code or code.startswith("// ⚠️"):
                        logger.warning(f"[{self.name}] Skipping {scenario_id}: No valid code")
                        result["errors"].append(f"{scenario_id}: No valid code to write")
                        continue
                    
                    # Generate filename
                    filename = f"{scenario_id.lower()}_{self._sanitize_filename(title)}.spec.ts"
                    filepath = story_dir / filename
                    
                    # Generate file content
                    content = self._generate_test_file_content(
                        scenario_title=title,
                        scenario_id=scenario_id,
                        story_key=story_key,
                        playwright_code=code,
                        review_score=review_score
                    )
                    
                    # Write file
                    filepath.write_text(content, encoding="utf-8")
                    
                    result["files_created"].append({
                        "filename": filename,
                        "path": str(filepath),
                        "scenario_id": scenario_id,
                        "title": title,
                        "size_bytes": len(content)
                    })
                    
                    logger.info(f"[{self.name}] ✅ Created: {filename}")
                    
                except Exception as e:
                    error_msg = f"{scenario.get('id', '?')}: {str(e)}"
                    result["errors"].append(error_msg)
                    logger.error(f"[{self.name}] ❌ Failed to write file: {error_msg}")
            
            # Generate index/barrel file
            if result["files_created"]:
                await self._generate_index_file(story_dir, story_key, result["files_created"])
            
            result["success"] = len(result["files_created"]) > 0
            logger.info(
                f"[{self.name}] Completed: {len(result['files_created'])} files created, "
                f"{len(result['errors'])} errors"
            )
            
        except Exception as e:
            result["errors"].append(f"Critical error: {str(e)}")
            logger.error(f"[{self.name}] Critical error: {e}")
        
        return result
    
    async def _generate_index_file(
        self,
        directory: Path,
        story_key: str,
        files: List[Dict]
    ):
        """Generate a README.md index file for the test suite."""
        timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")
        
        lines = [
            f"# Test Suite: {story_key}",
            "",
            f"> Auto-generated by **Jira QA AI Generator** (Agentic Pipeline)",
            f"> Generated at: {timestamp}",
            "",
            "## Test Files",
            "",
            "| File | Scenario | ID |",
            "|------|----------|-----|",
        ]
        
        for f in files:
            lines.append(f"| `{f['filename']}` | {f['title']} | {f['scenario_id']} |")
        
        lines.extend([
            "",
            "## Running Tests",
            "",
            "```bash",
            "# Run all tests in this suite",
            f"npx playwright test {directory.name}/",
            "",
            "# Run a specific test",
            f"npx playwright test {directory.name}/{files[0]['filename']}" if files else "",
            "",
            "# Run with UI mode",
            f"npx playwright test {directory.name}/ --ui",
            "```",
            "",
            "---",
            f"*Pipeline: Jira Story → AI Acceptance Criteria → AI Test Scenarios → AutomationEngineer Agent → CodeReviewer Agent → GitOps Agent*",
        ])
        
        readme_path = directory / "README.md"
        readme_path.write_text("\n".join(lines), encoding="utf-8")
        logger.info(f"[{self.name}] ✅ Created README.md index")
    
    async def git_commit_and_push(
        self,
        story_key: str,
        files_created: List[Dict],
        provider: str = "github",
        repo_url: Optional[str] = None,
        branch: Optional[str] = None,
        token: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Commit and push generated test files to a Git repository.
        """
        # Determine settings based on provider
        if provider.lower() == "github":
            repo_url = repo_url or getattr(settings, 'github_repo_url', None) or getattr(settings, 'git_repo_url', None)
            token = token or getattr(settings, 'github_token', None) or getattr(settings, 'git_token', None)
        elif provider.lower() == "azure":
            repo_url = repo_url or getattr(settings, 'azure_repo_url', None)
            token = token or getattr(settings, 'azure_devops_pat', None) or getattr(settings, 'git_token', None)
        else:
            repo_url = repo_url or getattr(settings, 'git_repo_url', None)
            token = token or getattr(settings, 'git_token', None)

        branch = branch or f"ai-tests/{story_key.lower()}-{provider.lower()}"
        
        result = {
            "success": False,
            "branch": branch,
            "commit_hash": None,
            "files_pushed": len(files_created),
            "repo_url": repo_url,
            "provider": provider,
            "error": None
        }
        
        if not repo_url:
            result["error"] = f"No Git repository URL configured for {provider}"
            logger.warning(f"[{self.name}] {result['error']}")
            return result
        
        try:
            # Build authenticated URL
            if token and "github.com" in repo_url:
                auth_url = repo_url.replace("https://", f"https://{token}@")
            elif token and "gitlab" in repo_url:
                auth_url = repo_url.replace("https://", f"https://oauth2:{token}@")
            elif token and ("dev.azure.com" in repo_url or "visualstudio.com" in repo_url):
                # Azure DevOps supports https://<PAT>@dev.azure.com/...
                auth_url = repo_url.replace("https://", f"https://{token}@")
            elif token:
                auth_url = repo_url.replace("https://", f"https://{token}@")
            else:
                auth_url = repo_url
            
            repo_folder = f".git_repo_{provider}"
            clone_dir = self.workspace_base / repo_folder
            
            # Clone or pull
            if clone_dir.exists() and (clone_dir / ".git").exists():
                try:
                    # Pull latest changes
                    await self._run_git(clone_dir, "git", "fetch", "origin")
                    await self._run_git(clone_dir, "git", "checkout", "main")
                    await self._run_git(clone_dir, "git", "pull", "origin", "main")
                except Exception as e:
                    logger.warning(f"[{self.name}] Repo fetch/pull failed, re-cloning: {e}")
                    self._cleanup_dir(clone_dir)
                    await self._run_git(
                        self.workspace_base,
                        "git", "clone", "--depth", "1", auth_url, repo_folder
                    )
            else:
                # Fresh clone
                self._cleanup_dir(clone_dir) # Ensure it's clean even if exists() returned False
                await self._run_git(
                    self.workspace_base,
                    "git", "clone", "--depth", "1", auth_url, repo_folder
                )
            
            # Configure Git user for this repo
            await self._run_git(clone_dir, "git", "config", "user.name", "AI Agent")
            await self._run_git(clone_dir, "git", "config", "user.email", "agent@jira-qa-ai.internal")
            
            # Create and checkout branch
            try:
                await self._run_git(clone_dir, "git", "checkout", "-b", branch)
            except Exception:
                await self._run_git(clone_dir, "git", "checkout", branch)
            
            # Copy test files to repo
            tests_path = getattr(settings, 'git_tests_path', 'tests/e2e/generated')
            target_dir = clone_dir / tests_path / story_key.lower().replace("-", "_")
            target_dir.mkdir(parents=True, exist_ok=True)
            
            source_dir = self.workspace_base / story_key.lower().replace("-", "_")
            if source_dir.exists():
                for src_file in source_dir.iterdir():
                    shutil.copy2(src_file, target_dir / src_file.name)
            
            # Git add, commit, push
            await self._run_git(clone_dir, "git", "add", "-A")
            
            commit_msg = (
                f"test({story_key}): auto-generated Playwright tests\n\n"
                f"Generated by AI Agentic Pipeline\n"
                f"- Story: {story_key}\n"
                f"- Files: {len(files_created)}\n"
                f"- Provider: {provider}\n"
                f"- Timestamp: {datetime.now(timezone.utc).isoformat()}"
            )
            
            # Check if there are changes to commit
            status = await self._run_git_output(clone_dir, "git", "status", "--porcelain")
            if not status:
                result["success"] = True
                result["error"] = "No changes to commit"
                return result

            await self._run_git(clone_dir, "git", "commit", "-m", commit_msg)
            await self._run_git(clone_dir, "git", "push", "origin", branch)
            
            # Get commit hash
            commit_hash = await self._run_git_output(
                clone_dir, "git", "rev-parse", "HEAD"
            )
            
            result["success"] = True
            result["commit_hash"] = commit_hash.strip() if commit_hash else None
            
            logger.info(
                f"[{self.name}] ✅ Pushed {len(files_created)} files to "
                f"{repo_url} on branch {branch} ({provider})"
            )
            
        except Exception as e:
            import traceback
            error_details = traceback.format_exc()
            result["error"] = str(e) or "Unknown Git error"
            logger.error(f"[{self.name}] ❌ Git push failed for {provider}: {result['error']}\n{error_details}")
        
        return result
    
    async def _run_git(self, cwd: Path, *args) -> None:
        """Run a git command using thread-safe subprocess for Windows compatibility."""
        command_str = ' '.join(args)
        if "clone" in args and "https://" in command_str and "@" in command_str:
            display_cmd = re.sub(r'https://[^@]+@', 'https://****@', command_str)
        else:
            display_cmd = command_str
            
        def _exec():
            return subprocess.run(
                args,
                cwd=str(cwd),
                capture_output=True,
                text=True,
                encoding='utf-8',
                errors='replace'
            )

        # Run in thread pool to avoid blocking event loop and bypass Proactor issues
        proc_result = await asyncio.to_thread(_exec)
        
        if proc_result.returncode != 0:
            error = proc_result.stderr.strip()
            stdout_msg = proc_result.stdout.strip()
            raise RuntimeError(f"Git failed: {display_cmd} | Error: {error} | Out: {stdout_msg}")
    
    async def _run_git_output(self, cwd: Path, *args) -> str:
        """Run a git command and return stdout."""
        def _exec():
            return subprocess.run(
                args,
                cwd=str(cwd),
                capture_output=True,
                text=True,
                encoding='utf-8',
                errors='replace'
            )

        proc_result = await asyncio.to_thread(_exec)
        
        if proc_result.returncode != 0:
            error = proc_result.stderr.strip()
            logger.warning(f"Git command '{' '.join(args)}' returned {proc_result.returncode}: {error}")
            
        return proc_result.stdout.strip()
