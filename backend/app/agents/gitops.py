"""
GitOps Agent
Intelligent agent responsible for managing test file generation and Git operations.

This agent handles:
  1. Creating well-structured test files from generated Playwright code
  2. Organizing files in the correct directory structure
  3. Managing Git operations (clone, branch, commit, push)
  4. Creating Pull Requests (optional)

In the agentic pipeline: AutomationEngineer → CodeReviewer → GitOps
"""

import os
import re
import asyncio
import shutil
from pathlib import Path
from datetime import datetime, timezone
from typing import Dict, Any, List, Optional

from loguru import logger
from app.core.config import settings


class GitOpsAgent:
    """
    Agent responsible for writing generated test files to a Git repository.
    
    This agent operates autonomously as part of the agentic pipeline:
    - Receives reviewed Playwright code
    - Creates properly structured .spec.ts files
    - Commits and pushes to the target repository
    
    It supports two modes:
    - LOCAL: Write files to a local directory (no Git push)
    - GIT: Clone repo, write files, commit, and push
    """
    
    def __init__(self):
        self.name = "GitOpsAgent"
        self.workspace_base = Path(settings.git_tests_workspace)
        self.workspace_base.mkdir(parents=True, exist_ok=True)
    
    def _sanitize_filename(self, title: str) -> str:
        """Convert a scenario title to a valid filename."""
        name = title.lower()
        name = re.sub(r'[^a-z0-9\s-]', '', name)
        name = re.sub(r'[\s]+', '-', name.strip())
        name = re.sub(r'-+', '-', name)
        return name[:80]  # Limit length
    
    def _generate_test_file_content(
        self,
        scenario_title: str,
        scenario_id: str,
        story_key: str,
        playwright_code: str,
        review_score: Optional[int] = None,
    ) -> str:
        """
        Generate a complete, well-structured .spec.ts file content.
        
        Wraps the generated Playwright code with proper imports,
        metadata comments, and file structure.
        """
        timestamp = datetime.now(timezone.utc).isoformat()
        
        # Check if code already has imports
        has_imports = "import" in playwright_code and "playwright" in playwright_code.lower()
        
        header = f"""/**
 * =============================================================================
 * Auto-Generated Playwright Test
 * =============================================================================
 * 
 * Story:     {story_key}
 * Scenario:  {scenario_title}
 * ID:        {scenario_id}
 * Generated: {timestamp}
 * Generator: Jira QA AI Generator (Agentic Pipeline)
 * 
 * Pipeline:  Story → AC → Scenarios → AutomationEngineer → CodeReviewer → GitOps
 * Review:    {"Score " + str(review_score) + "/10" if review_score else "N/A"}
 * 
 * ⚠️  This file was automatically generated by the AI agentic pipeline.
 *     Manual modifications may be overwritten on regeneration.
 * =============================================================================
 */
"""
        
        if has_imports:
            return f"{header}\n{playwright_code}\n"
        else:
            imports = """import { test, expect } from '@playwright/test';
"""
            return f"{header}\n{imports}\n{playwright_code}\n"
    
    async def write_test_files(
        self,
        story_key: str,
        scenarios: List[Dict[str, Any]],
    ) -> Dict[str, Any]:
        """
        Write test files to the local workspace.
        
        Args:
            story_key: Jira story key (e.g., "PROJ-123")
            scenarios: List of scenario dicts with keys:
                - id, title, playwright_code, review_score
                
        Returns:
            Result dict with created file paths and status
        """
        logger.info(f"[{self.name}] Writing test files for {story_key}...")
        
        result = {
            "success": False,
            "story_key": story_key,
            "files_created": [],
            "directory": "",
            "errors": []
        }
        
        try:
            # Create story-specific directory
            story_dir = self.workspace_base / story_key.lower().replace("-", "_")
            story_dir.mkdir(parents=True, exist_ok=True)
            result["directory"] = str(story_dir)
            
            for scenario in scenarios:
                try:
                    scenario_id = scenario.get("id", "TS-000")
                    title = scenario.get("title", "untitled")
                    code = scenario.get("playwright_code", "")
                    review_score = scenario.get("review_score")
                    
                    if not code or code.startswith("// ⚠️"):
                        logger.warning(f"[{self.name}] Skipping {scenario_id}: No valid code")
                        result["errors"].append(f"{scenario_id}: No valid code to write")
                        continue
                    
                    # Generate filename
                    filename = f"{scenario_id.lower()}_{self._sanitize_filename(title)}.spec.ts"
                    filepath = story_dir / filename
                    
                    # Generate file content
                    content = self._generate_test_file_content(
                        scenario_title=title,
                        scenario_id=scenario_id,
                        story_key=story_key,
                        playwright_code=code,
                        review_score=review_score
                    )
                    
                    # Write file
                    filepath.write_text(content, encoding="utf-8")
                    
                    result["files_created"].append({
                        "filename": filename,
                        "path": str(filepath),
                        "scenario_id": scenario_id,
                        "title": title,
                        "size_bytes": len(content)
                    })
                    
                    logger.info(f"[{self.name}] ✅ Created: {filename}")
                    
                except Exception as e:
                    error_msg = f"{scenario.get('id', '?')}: {str(e)}"
                    result["errors"].append(error_msg)
                    logger.error(f"[{self.name}] ❌ Failed to write file: {error_msg}")
            
            # Generate index/barrel file
            if result["files_created"]:
                await self._generate_index_file(story_dir, story_key, result["files_created"])
            
            result["success"] = len(result["files_created"]) > 0
            logger.info(
                f"[{self.name}] Completed: {len(result['files_created'])} files created, "
                f"{len(result['errors'])} errors"
            )
            
        except Exception as e:
            result["errors"].append(f"Critical error: {str(e)}")
            logger.error(f"[{self.name}] Critical error: {e}")
        
        return result
    
    async def _generate_index_file(
        self,
        directory: Path,
        story_key: str,
        files: List[Dict]
    ):
        """Generate a README.md index file for the test suite."""
        timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")
        
        lines = [
            f"# Test Suite: {story_key}",
            "",
            f"> Auto-generated by **Jira QA AI Generator** (Agentic Pipeline)",
            f"> Generated at: {timestamp}",
            "",
            "## Test Files",
            "",
            "| File | Scenario | ID |",
            "|------|----------|-----|",
        ]
        
        for f in files:
            lines.append(f"| `{f['filename']}` | {f['title']} | {f['scenario_id']} |")
        
        lines.extend([
            "",
            "## Running Tests",
            "",
            "```bash",
            "# Run all tests in this suite",
            f"npx playwright test {directory.name}/",
            "",
            "# Run a specific test",
            f"npx playwright test {directory.name}/{files[0]['filename']}" if files else "",
            "",
            "# Run with UI mode",
            f"npx playwright test {directory.name}/ --ui",
            "```",
            "",
            "---",
            f"*Pipeline: Jira Story → AI Acceptance Criteria → AI Test Scenarios → AutomationEngineer Agent → CodeReviewer Agent → GitOps Agent*",
        ])
        
        readme_path = directory / "README.md"
        readme_path.write_text("\n".join(lines), encoding="utf-8")
        logger.info(f"[{self.name}] ✅ Created README.md index")
    
    async def git_commit_and_push(
        self,
        story_key: str,
        files_created: List[Dict],
        repo_url: Optional[str] = None,
        branch: Optional[str] = None,
        token: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Commit and push generated test files to a Git repository.
        
        Args:
            story_key: Jira story key
            files_created: List of created file dicts
            repo_url: Git repository URL (defaults to config)
            branch: Target branch (defaults to "ai-tests/{story_key}")
            token: Git authentication token
            
        Returns:
            Result dict with commit info
        """
        repo_url = repo_url or getattr(settings, 'git_repo_url', None)
        token = token or getattr(settings, 'git_token', None)
        branch = branch or f"ai-tests/{story_key.lower()}"
        
        result = {
            "success": False,
            "branch": branch,
            "commit_hash": None,
            "files_pushed": len(files_created),
            "repo_url": repo_url,
            "error": None
        }
        
        if not repo_url:
            result["error"] = "No Git repository URL configured (GIT_REPO_URL)"
            logger.warning(f"[{self.name}] {result['error']}")
            return result
        
        try:
            # Build authenticated URL
            if token and "github.com" in repo_url:
                auth_url = repo_url.replace("https://", f"https://x-access-token:{token}@")
            elif token and "gitlab" in repo_url:
                auth_url = repo_url.replace("https://", f"https://oauth2:{token}@")
            elif token and ("dev.azure.com" in repo_url or "visualstudio.com" in repo_url):
                # Azure DevOps supports https://<PAT>@dev.azure.com/...
                auth_url = repo_url.replace("https://", f"https://{token}@")
            elif token:
                auth_url = repo_url.replace("https://", f"https://{token}@")
            else:
                auth_url = repo_url
            
            clone_dir = self.workspace_base / ".git_repo"
            
            # Clone or pull
            if clone_dir.exists():
                # Pull latest changes
                await self._run_git(clone_dir, "git", "fetch", "origin")
                await self._run_git(clone_dir, "git", "checkout", "main")
                await self._run_git(clone_dir, "git", "pull", "origin", "main")
            else:
                # Fresh clone
                await self._run_git(
                    self.workspace_base,
                    "git", "clone", "--depth", "1", auth_url, str(clone_dir)
                )
            
            # Create and checkout branch
            try:
                await self._run_git(clone_dir, "git", "checkout", "-b", branch)
            except Exception:
                await self._run_git(clone_dir, "git", "checkout", branch)
            
            # Copy test files to repo
            tests_path = getattr(settings, 'git_tests_path', 'tests/e2e/generated')
            target_dir = clone_dir / tests_path / story_key.lower().replace("-", "_")
            target_dir.mkdir(parents=True, exist_ok=True)
            
            source_dir = self.workspace_base / story_key.lower().replace("-", "_")
            if source_dir.exists():
                for src_file in source_dir.iterdir():
                    shutil.copy2(str(src_file), str(target_dir / src_file.name))
            
            # Git add, commit, push
            await self._run_git(clone_dir, "git", "add", "-A")
            
            commit_msg = (
                f"test({story_key}): auto-generated Playwright tests\n\n"
                f"Generated by AI Agentic Pipeline\n"
                f"- Story: {story_key}\n"
                f"- Files: {len(files_created)}\n"
                f"- Pipeline: Story → AC → Scenarios → Code → Review → GitOps\n"
                f"- Timestamp: {datetime.now(timezone.utc).isoformat()}"
            )
            
            await self._run_git(clone_dir, "git", "commit", "-m", commit_msg)
            await self._run_git(clone_dir, "git", "push", "origin", branch)
            
            # Get commit hash
            commit_hash = await self._run_git_output(
                clone_dir, "git", "rev-parse", "HEAD"
            )
            
            result["success"] = True
            result["commit_hash"] = commit_hash.strip() if commit_hash else None
            
            logger.info(
                f"[{self.name}] ✅ Pushed {len(files_created)} files to "
                f"{repo_url} on branch {branch}"
            )
            
        except Exception as e:
            result["error"] = str(e)
            logger.error(f"[{self.name}] ❌ Git push failed: {e}")
        
        return result
    
    async def _run_git(self, cwd: Path, *args) -> None:
        """Run a git command."""
        proc = await asyncio.create_subprocess_exec(
            *args,
            cwd=str(cwd),
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        stdout, stderr = await proc.communicate()
        
        if proc.returncode != 0:
            error = stderr.decode().strip()
            raise RuntimeError(f"Git command failed: {' '.join(args)}: {error}")
    
    async def _run_git_output(self, cwd: Path, *args) -> str:
        """Run a git command and return stdout."""
        proc = await asyncio.create_subprocess_exec(
            *args,
            cwd=str(cwd),
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        stdout, stderr = await proc.communicate()
        return stdout.decode().strip()
